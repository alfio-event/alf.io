/**
 * This file is part of alf.io.
 *
 * alf.io is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * alf.io is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with alf.io.  If not, see <http://www.gnu.org/licenses/>.
 */
package alfio.repository;

import alfio.model.BillingDocument;
import ch.digitalfondue.npjt.*;

import java.time.ZonedDateTime;
import java.util.List;
import java.util.Optional;

@QueryRepository
public interface BillingDocumentRepository {

    String LOAD_ALL_BY_EVENT_ID = "select a.* from billing_document a inner join" +
        " (select max(generation_ts) as time,reservation_id_fk from billing_document where status = 'VALID' and type = 'INVOICE' and event_id_fk = :eventId group by reservation_id_fk) b" +
        " on a.generation_ts = b.time and a.reservation_id_fk = b.reservation_id_fk" +
        " union select * from billing_document where status = 'VALID' and event_id_fk = :eventId and type <> 'INVOICE'";

    @Query("select * from billing_document where reservation_id_fk = :reservationId and status = 'VALID' order by generation_ts desc limit 1")
    Optional<BillingDocument> findLatestByReservationId(@Bind("reservationId") String reservationId);

    @Query("select * from billing_document where reservation_id_fk = :reservationId and id = :id")
    Optional<BillingDocument> findByIdAndReservationId(@Bind("id") long documentId, @Bind("reservationId") String reservationId);

    @Query("select * from billing_document where id = :id")
    Optional<BillingDocument> findById(@Bind("id") long documentId);

    @Query("update billing_document set status = :status where reservation_id_fk = :reservationId and id = :id")
    int updateStatus(@Bind("id") long documentId, @Bind("status") BillingDocument.Status status, @Bind("reservationId") String reservationId);

    @Query("update billing_document set status = 'NOT_VALID' where type = :type and id < :currentId and reservation_id_fk = :reservationId")
    int invalidateAllPreviousDocumentsOfType(@Bind("type") BillingDocument.Type type,
                                             @Bind("currentId") Long currentId,
                                             @Bind("reservationId") String reservationId);

    @Query("select * from billing_document where reservation_id_fk = :reservationId order by generation_ts desc, id desc")
    List<BillingDocument> findAllByReservationId(@Bind("reservationId") String reservationId);

    @Query("insert into billing_document(event_id_fk, number, reservation_id_fk, type, model, generation_ts, status, organization_id_fk)" +
        " values(:eventId, :number, :reservationId, :type, :model, :generationTimestamp, 'VALID', :organizationId)")
    @AutoGeneratedKey("id")
    AffectedRowCountAndKey<Long> insert(@Bind("eventId") Integer eventId,
                                        @Bind("reservationId") String reservationId,
                                        @Bind("number") String number,
                                        @Bind("type") BillingDocument.Type type,
                                        @Bind("model") String modelJson,
                                        @Bind("generationTimestamp")ZonedDateTime generationTs,
                                        @Bind("organizationId") int organizationId);

    @Query("select * from billing_document a inner join " +
        "(select max(generation_ts) as time,reservation_id_fk from billing_document where status = 'VALID' and type = :type and event_id_fk = :eventId group by reservation_id_fk) b" +
        " on a.generation_ts = b.time and a.reservation_id_fk = b.reservation_id_fk")
    List<BillingDocument> findAllOfTypeForEvent(@Bind("type") BillingDocument.Type type, @Bind("eventId") int eventId);

    @Query(LOAD_ALL_BY_EVENT_ID + " order by reservation_id_fk, generation_ts")
    List<BillingDocument> findAllForEvent(@Bind("eventId") int eventId);

    @Query("select count(*) from (" + LOAD_ALL_BY_EVENT_ID + ") docs")
    Integer countAllForEvent(@Bind("eventId") int eventId);

    @Query("delete from billing_document where reservation_id_fk = :reservationId")
    int deleteForReservation(@Bind("reservationId") String reservationId);

    @Query("delete from billing_document where reservation_id_fk in (:reservationIds) and event_id_fk = :eventId")
    int deleteForReservations(@Bind("reservationIds") List<String> reservationIds, @Bind("eventId") int eventId);

    @Query("select id from billing_document a inner join" +
        "(select max(generation_ts) as time,reservation_id_fk from billing_document where status = 'VALID' and type = 'INVOICE' and event_id_fk = :eventId group by reservation_id_fk) b " +
        " on a.generation_ts = b.time and a.reservation_id_fk = b.reservation_id_fk "+
        " where a.event_id_fk = :eventId and a.type = 'INVOICE' and b.time between :start and :end")
    List<Integer> findMatchingInvoiceIds(@Bind("eventId") int eventId, @Bind("start") ZonedDateTime start, @Bind("end") ZonedDateTime end);

    @Query("select min(generation_ts) from billing_document where event_id_fk = :eventId and type = 'INVOICE' and status = 'VALID'")
    Optional<ZonedDateTime> findFirstInvoiceGenerationDate(@Bind("eventId") int eventId);

    @Query("select exists(select id from billing_document where id = :id and reservation_id_fk = :reservationId)")
    Boolean checkBillingDocumentExistsForReservation(@Bind("id") long billingDocumentId, @Bind("reservationId") String reservationId);

    @Query("select id from billing_document where id in (:documentIds) and event_id_fk = :eventId ")
    List<Long> findByIdsAndEvent(@Bind("documentIds") List<Long> documentIds, @Bind("eventId") int eventId);
}
