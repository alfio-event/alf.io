/**
 * This file is part of alf.io.
 *
 * alf.io is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * alf.io is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with alf.io.  If not, see <http://www.gnu.org/licenses/>.
 */
package alfio.repository;

import alfio.model.poll.Poll;
import alfio.model.poll.PollOption;
import alfio.model.poll.PollOptionStatistics;
import alfio.model.support.Array;
import alfio.model.support.JSONData;
import ch.digitalfondue.npjt.*;

import java.util.List;
import java.util.Map;
import java.util.Optional;

@QueryRepository
public interface PollRepository {


    String INSERT_OPTION = "insert into poll_option(poll_id_fk, title, description, organization_id_fk) " +
        " values(:pollId, (:title)::jsonb, (:description)::jsonb, :organizationId)";

    @Query("insert into poll (title, description, allowed_tags, poll_order, event_id_fk, organization_id_fk) " +
        "values(:title::jsonb, :description::jsonb, :allowedTags::text[], :pollOrder, :eventId, :orgId)")
    @AutoGeneratedKey("id")
    AffectedRowCountAndKey<Long> insert(@Bind("title") @JSONData Map<String, String> title,
                                  @Bind("description") @JSONData Map<String, String> description,
                                  @Bind("allowedTags") @Array List<String> allowedTags,
                                  @Bind("pollOrder") int pollOrder,
                                  @Bind("eventId") int eventId,
                                  @Bind("orgId") int organizationId);

    @Query("update poll set title = :title::jsonb, description = :description::jsonb, allowed_tags = :allowedTags::text[]," +
        " poll_order = :pollOrder where id = :id and event_id_fk = :eventId")
    int update(@Bind("title") @JSONData Map<String, String> title,
               @Bind("description") @JSONData Map<String, String> description,
               @Bind("allowedTags") @Array List<String> allowedTags,
               @Bind("pollOrder") int pollOrder,
               @Bind("id") long pollId,
               @Bind("eventId") int eventId);

    @Query("update poll set status = :status::POLL_STATUS where id = :id and event_id_fk = :eventId")
    int updateStatus(@Bind("status") Poll.PollStatus status, @Bind("id") Long id, @Bind("eventId") int eventId);

    @Query("select * from poll where event_id_fk = :eventId order by poll_order asc")
    List<Poll> findAllForEvent(@Bind("eventId") int eventId);

    @Query("select * from poll where event_id_fk = :eventId and status = 'OPEN' order by poll_order asc")
    List<Poll> findActiveForEvent(@Bind("eventId") int eventId);

    @Query("select * from poll where event_id_fk = :eventId and status = 'OPEN' and id = :id")
    Optional<Poll> findSingleActiveForEvent(@Bind("eventId") int eventId,
                                            @Bind("id") Long pollId);

    @Query("select * from poll where event_id_fk = :eventId and id = :id")
    Optional<Poll> findSingleForEvent(@Bind("eventId") int eventId, @Bind("id") Long pollId);

    // options

    @Query(INSERT_OPTION)
    @AutoGeneratedKey("id")
    AffectedRowCountAndKey<Long> insertOption(@Bind("pollId") Long pollId,
                     @Bind("title") @JSONData Map<String, String> title,
                     @Bind("description") @JSONData Map<String, String> description,
                     @Bind("organizationId") Integer organizationId);

    @Query(type = QueryType.TEMPLATE, value = INSERT_OPTION)
    String bulkInsertOptions();

    @Query(type = QueryType.TEMPLATE, value = "update poll_option set title = :title::jsonb, description = :description::jsonb where id = :id and poll_id_fk = :pollId")
    String bulkUpdateOptions();

    @Query("select * from poll_option where poll_id_fk = :pollId order by id")
    List<PollOption> getOptionsForPoll(@Bind("pollId") long pollId);

    @Query("select count(*) from poll_option " +
        " join poll on poll_option.poll_id_fk = poll.id" +
        " where poll_option.id = :optionId and poll.id = :pollId and poll.event_id_fk = :eventId")
    Integer checkPollOption(@Bind("optionId") long optionId, @Bind("pollId") long pollId, @Bind("eventId") int eventId);

    // answers

    @Query("insert into poll_answer(poll_id_fk, poll_option_id_fk, ticket_id_fk, organization_id_fk)" +
        " values(:pollId, :optionId, :ticketId, :orgId)" +
        " on conflict(poll_id_fk, ticket_id_fk) do update set poll_option_id_fk = excluded.poll_option_id_fk")
    int registerAnswer(@Bind("pollId") long pollId,
                       @Bind("optionId") long optionId,
                       @Bind("ticketId") int ticketId,
                       @Bind("orgId") int organizationId);

    @Query("select pa.poll_option_id_fk, count(*) as votes from poll_answer pa" +
        "    join poll p on p.id = pa.poll_id_fk " +
        " where p.id = :pollId and p.event_id_fk = :eventId group by 1")
    List<PollOptionStatistics> getStatisticsFor(@Bind("pollId") Long pollId, @Bind("eventId") int eventId);

    @Query("delete from poll where id = :pollId and event_id_fk = :eventId and organization_id_fk = :orgId")
    int deletePoll(@Bind("pollId") long pollId, @Bind("eventId") int eventId, @Bind("orgId") int organizationId);

    @Query("delete from poll_option where id = :optionId and poll_id_fk = :pollId")
    int deleteOption(@Bind("pollId") long pollId, @Bind("optionId") long optionId);

}
